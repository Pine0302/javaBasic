+ overload 参数个数或者返回类型不同，参数名相同，和参数类型无关
  
> JAVA运算
+ 负数的二进制 就是正数的二进制取反 +1
+ 负数的二进制 最高位都是1
  + 6 00000110
  + -6 11111010
  + ~6 + 1 = -7 + 1 = 8
+ 左移 << ：就是乘以2的次幂运算，移几位就是几次幂
+ 右移 >> ：就是除以2的次幂运算，移几位就是几次幂
+ 右移时，原最高为是什么，空位就补什么
+ 无符号右移 >>> 无论原最高位是什么，空位都补0（比如进制转换）
+ 与 & 可用于获取二进制中的有效位1
+ 或 | 
+ 异或 ^  ： 6^3^3 = 6 一个数异或另一个数两次，结果还是这个数。（加密？）
> java对内存空间的划分
+ 栈内存：
  + 可以存储局部变量（只要是在方法中定义的变量都是局部变量） 
  + 一旦变量的生命周期结束，该变量就被释放
+ 堆： 存储的都是实体（对象）
  + 可以存储成员变量
  + 每一个实体都有一个首地址值
  + 堆内存中的变量都有默认初始化值。不同类型不一样。int-0 double-0.0 boolean-false char-'\u0000'
  + 当实体不再使用时，就会被垃圾回收机制处理。
+ 方法区
+ 本地方法区
+ 寄存器
```
1.方法:当一个方法执行时,该方法都会建立自己的内存栈,在该方法内定义的变量将会逐个放入内存栈中,
随着方法执行结束,该方法的内存栈也将自然销毁.因此,所有在方法中定义的局部变量都是放在栈内存中的;
2.对象:创建一个对象时,该对象保存到堆内存(运行时数据区)中,以便反复使用.
堆内存中的对象不会随方法的结束而销毁,即使方法结束后,这个对象还可能被另一个引用变量所引用,
则这个对象依然不会被销毁,只有当一个对象没有任何引用变量引用它时,系统的垃圾回收器才会在合适的时候回收它.
```

> 数组使用的核心思想
+ 容器特点 1.固定长度   2.元素都有索引
+ 什么时候使用容器？数据多了，必须先进行存储，然后进行操作
+ 对于数组容器什么时候用呢？数据多，个数确定，而且有对应关系
+ 在分析需求时
  + 需求中的数据是否有对应的有序编号
  + 需求中的数据是否需要有序的编号
  + 如果有，就用数组存储
+ 查表法：数据之间存在对应关系，通过关系中的一方查询另一方。当对应关系存在但没有一方是有序编号是，使用另一个容器map。

```
在程序中，调用方法并且把数组/(对象)的名称作为参数传递到方法中。本质上是传递数组的地址值。 既然传递的是数组的地址，那么方法就可以通过数组的地址改变内存中数组的内容。
类似于C语言中调用函数传递数组的指针一样。可以在函数中通过指针改变数组的内容。
所以在JAVA当中，数组为引用类型，可以把数组作为参数传递到方法中去改变数组。
对比php，如果php希望给函数传递数组参数时同时可以改动这个数组，在函数中入参需要给形参数组前加上&
```
>成员变量和局部变量的区别
+ 定义位置不同
  + 成员变量定义在类中
  + 局部变量定义在方法中及语句里
+ 在内存中的位置不同
  + 成员变量存储在堆内存中
  + 局部变量存储在栈内存中
+ 生命周期不同
  + 成员变量随着对象的出现而出现，随着对象消失而消失
  + 局部变量随着方法的运行而出现，随着方法的弹栈而消失 
+ 初始化不同
  + 成员变量因为在堆内存中，所以有默认初始化值。
  + 局部变量没有默认初始化值，必须初始化后才能使用。 
```
void show(){
  int x = 4;
  int y;
}
//show 方法进栈之后， x 是有开辟空间的，而y没有
```
+ 面向对象的三个特征 ：封装，继承，多态

>封装
+ 表现
  + 1.函数就是一个最基本的封装体
  + 2.类其实也是一个封装体
+ 特性
  + 1.提高了代码的复用性
  + 2.隐藏了实现细节，还要对外提供可以访问的方式，便于调用者调用
  + 3.提高了安全性
  + 4.私有（private）是封装的提现之一

>构造函数
+ 1.没有返回值类型，因为构造对象，创建完就结束
+ 2.构造函数名称和类名一致
+ 3.没有具体的返回值
+ 4.只要定义一个类，如果没有自定义构造函数，编译器编译这个类时会添加一个空构造函数到class文件中
+ 5.如果在类中自定义了构造函数，那么编译器就不会增加空构造函数
+ 构造函数细节
  + 1.一个类里面可以有多个构造函数,他们的存在是以重载的形式存在的
  + 2.构造函数中也是有return 语句的，用户结束初始化动作
  + 构造函数是否能被private 修饰？能，作用：其他程序无法创建该类的对象（单例模式？）
  ```
  class person(){
    private person(){}
  }
  main(){
    Person p = new Person();  //报错！创建对象无法初始化
  }
  ```
  + 构造函数之间的互相调用 （this(实参列表)） 哪个对象调用了this所在的函数，this就代表那个对象
    + 一个对象的构造函数在调用该对象的其他构造函数的时候，该语句必须在构造函数的第一行。原因：初始化动作要先执行 
    + 一个构造函数不能调用两个构造函数，原因见上一条
  
+ this 可以用this标识哪些变量是成员变量
+ 这个标识可以省略不写，但是当局部变量和成员变量同名时，必须用 this. 来表明成员变量