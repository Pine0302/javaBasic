+ overload 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同
+ 成员变量的私有(private)不会改变变量的存储位置，静态（static）会
  
> JAVA运算
+ 负数的二进制 就是正数的二进制取反 +1
+ 负数的二进制 最高位都是1
  + 6 00000110
  + -6 11111010
  + ~6 + 1 = -7 + 1 = 8
+ 左移 << ：就是乘以2的次幂运算，移几位就是几次幂
+ 右移 >> ：就是除以2的次幂运算，移几位就是几次幂
+ 右移时，原最高为是什么，空位就补什么
+ 无符号右移 >>> 无论原最高位是什么，空位都补0（比如进制转换）
+ 与 & 可用于获取二进制中的有效位1
+ 或 | 
+ 异或 ^  ： 6^3^3 = 6 一个数异或另一个数两次，结果还是这个数。（加密？）
> java对内存空间的划分
+ 栈内存：
  + 可以存储局部变量（只要是在方法中定义的变量都是局部变量） 
  + 一旦变量的生命周期结束，该变量就被释放
+ 堆： 存储的都是实体（对象）
  + 可以存储成员变量
  + 每一个实体都有一个首地址值
  + 堆内存中的变量都有默认初始化值。不同类型不一样。int-0 double-0.0 boolean-false char-'\u0000'
  + 当实体不再使用时，就会被垃圾回收机制处理。
+ 方法区
+ 本地方法区
+ 寄存器
```
1.方法:当一个方法执行时,该方法都会建立自己的内存栈,在该方法内定义的变量将会逐个放入内存栈中,
随着方法执行结束,该方法的内存栈也将自然销毁.因此,所有在方法中定义的局部变量都是放在栈内存中的;
2.对象:创建一个对象时,该对象保存到堆内存(运行时数据区)中,以便反复使用.
堆内存中的对象不会随方法的结束而销毁,即使方法结束后,这个对象还可能被另一个引用变量所引用,
则这个对象依然不会被销毁,只有当一个对象没有任何引用变量引用它时,系统的垃圾回收器才会在合适的时候回收它.
```

> 数组使用的核心思想
+ 容器特点 1.固定长度   2.元素都有索引
+ 什么时候使用容器？数据多了，必须先进行存储，然后进行操作
+ 对于数组容器什么时候用呢？数据多，个数确定，而且有对应关系
+ 在分析需求时
  + 需求中的数据是否有对应的有序编号
  + 需求中的数据是否需要有序的编号
  + 如果有，就用数组存储
+ 查表法：数据之间存在对应关系，通过关系中的一方查询另一方。当对应关系存在但没有一方是有序编号是，使用另一个容器map。

```
在程序中，调用方法并且把数组/(对象)的名称作为参数传递到方法中。本质上是传递数组的地址值。 既然传递的是数组的地址，那么方法就可以通过数组的地址改变内存中数组的内容。
类似于C语言中调用函数传递数组的指针一样。可以在函数中通过指针改变数组的内容。
所以在JAVA当中，数组为引用类型，可以把数组作为参数传递到方法中去改变数组。
对比php，如果php希望给函数传递数组参数时同时可以改动这个数组，在函数中入参需要给形参数组前加上&
```
>成员变量和局部变量的区别
+ 定义位置不同
  + 成员变量定义在类中
  + 局部变量定义在方法中及语句里
+ 在内存中的位置不同
  + 成员变量存储在堆内存中
  + 局部变量存储在栈内存中
+ 生命周期不同
  + 成员变量随着对象的出现而出现，随着对象消失而消失
  + 局部变量随着方法的运行而出现，随着方法的弹栈而消失 
+ 初始化不同
  + 成员变量因为在堆内存中，所以有默认初始化值。
  + 局部变量没有默认初始化值，必须初始化后才能使用。 
```
void show(){
  int x = 4;
  int y;
}
//show 方法进栈之后， x 是有开辟空间的，而y没有
```
+ 面向对象的三个特征 ：封装，继承，多态

>封装
+ 表现
  + 1.函数就是一个最基本的封装体
  + 2.类其实也是一个封装体
+ 特性
  + 1.提高了代码的复用性
  + 2.隐藏了实现细节，还要对外提供可以访问的方式，便于调用者调用
  + 3.提高了安全性
  + 4.私有（private）是封装的提现之一

>构造函数
+ 1.没有返回值类型，因为构造对象，创建完就结束
+ 2.构造函数名称和类名一致
+ 3.没有具体的返回值
+ 4.只要定义一个类，如果没有自定义构造函数，编译器编译这个类时会添加一个空构造函数到class文件中
+ 5.如果在类中自定义了构造函数，那么编译器就不会增加空构造函数
+ 构造函数细节
  + 1.一个类里面可以有多个构造函数,他们的存在是以重载的形式存在的
  + 2.构造函数中也是有return 语句的，用户结束初始化动作
  + 构造函数是否能被private 修饰？能，作用：其他程序无法创建该类的对象（单例模式？）
  ```
  class person(){
    private person(){}
  }
  main(){
    Person p = new Person();  //报错！创建对象无法初始化
  }
  ```
  + 构造函数之间的互相调用 （this(实参列表)） 哪个对象调用了this所在的函数，this就代表那个对象
    + 一个对象的构造函数在调用该对象的其他构造函数的时候，该语句必须在构造函数的第一行。原因：初始化动作要先执行 
    + 一个构造函数不能调用两个构造函数，原因见上一条
  
+ this 可以用this标识哪些变量是成员变量
+ 这个标识可以省略不写，但是当局部变量和成员变量同名时，必须用 this. 来表明成员变量
  
> static 静态修饰
+ 被 静态 static 修饰的方法除了可以被对象调用之外，还可以被类名调用
+ 定义的功能，如果不需要访问类中的非静态成员变量的时候，该功能就需要静态修饰
>>静态方法使用注意事项
+ 静态方法不能访问非静态的成员,但是非静态方法可以访问静态成员,静态方法的弊端在于访问的局限性,好处是可以直接被类名调用
+ 静态方法中不允许出现this super 关键字
>>原理说明
+ 静态是随着类的加载就加载了,也是随着类的消失而消失了.
+ 静态优先于对象存在,被对象共享.(不要用对象去调用静态方法和参数)
+ 因为静态先存在于内存中无法方位后来的对象中的数据,所以静态方法无法方问非静态.而且无法书写this,因为这时对象有可能不存在,this没有任何指向.

```
/**
静态的主函数
public static void main(String[] args)

public : 权限最大
static ：不需要对象，直接用给定的类名就可以访问该函数了
void   ：不需要返回值
main   ：函数名，该名称是固定的
String[] args ： 主函数的参数列表，字符传数组类型的参数。
args ：参数，该名称就是一个变量名

class MainDemo {
    public static void main(String[] args) {
       System.out.println(args);//[Ljava.lang.String;@4dc63996  //说明jvm传递了一个字符串类型的数组实体
       System.out.println(args.length);//0 jvm 传递的是 new String[0];
       System.out.println(args[0]);//java.lang.ArrayIndexOutOfBoundsException:
       // java MainDemo pine jack ->args.length = 2 ;args[0] = pine

    }
}

*/
```
>> 静态变量
+ 当该成员变量的值,每一个对象都一致时,就对该成员变量进行静态修饰.
+ 静态变量和成员变量的区别
  + 1.所属的范围不同,
    + 静态变量所属于类,成员变量所属于对象,
    + 静态变量也称为类变量,成员变量也称为实例变量
  + 2.调用不同
    + 静态变量可以被对象和类调用(一般用类名调用)
    + 成员变量只能被对象调用
  + 加载时期不同
    + 静态变量随着类的加载而加载
    + 成员变量随着对象的加载而加载
  + 内存存储区域不同  
    + 静态变量存储在方法区中.(数据共享区)
    + 成员变量存储在堆内存中.

>> 静态代码块（StaticCodeDemo）
+ 特点：随着类的加载而执行，而且仅执行一次
+ 作用：给类初始化（注册类到本地或者某个应用程序上面）
```
class Demo
{
    static int x = 9;  //静态变量有两次初始化，一次默认初始化（int=>0），一次显示初始化
    static             //静态代码块，在静态变量显示初始化之后执行
    {
        System.out.println("类一加载就执行的部分..."+x); 
    }
    static void show(){
        System.out.println("show run");
    }

}
```
>> 局部代码块
```
class Demo {
    int x = 9; // 成员变量有两次初始化，一次默认初始化，一次显示初始化
    { // 构造代码块，只要创建对象就会被调用，在成员变量显示初始化之后执行。给所有对象初始化；构造函数只给对应对象针对性初始化。
      // 这里可以定义不同构造函数的共性代码
        System.out.println("code run----" + x);
        System.out.println("哈哈哈哈");
    }
    Demo() {
        System.out.println("demo run");
    }
    Demo(int x) {
        System.out.println("demo run...." + x);
    }

}

class ConstructorCodeDemo {
    public static void main(String[] args) {
        new Demo();
        new Demo(5);
        { //局部代码块 作用：可以控制局部变量的生命周期，类似for循环中的x
            int x = 10;
            System.out.println("demo run...." + x);
        }
       // System.out.println("demo run...." +x);
        System.out.println("demo run....");
    }
}
```
> 对象的创建过程
```
class Demo
{
    Static int x; 
    int y = 1; 
    static
    {
        System.out.println("static code ... x = "+x); 
    }

    {
        System.out.println("cons code ... y = "+y); 
    }

    Demo()
    {
        System.out.println("cons function ... y = "+y); 
    }

}

class CreateObjectTest 
{
    public static void main(String[] args) 
    {
        /*
        1.加载Demo.class文件进方法区,并进行空间分配
        2.如果有静态变量,先默认初始化,再显示初始化
        3.如果有静态代码块,要执行,仅一次.
        4.通过new 在堆内存中开辟空间,并明确首地址值.
        5.对对象中的属性进行默认初始化
        6.调用对应的构造函数进行初始化
        7.构造函数内部.
            7.1 调用父类构造函数super();
            7.2 成员变量的显示初始化
            7.3 构造代码块初始化
            7.4 构造函数内自定义内容初始化
        8.对象初始化完毕后,将地址赋值给d引用变量.
        */

       Demo d = new Demo();
    }
}
```

> 接口
+  接口和抽象类的区别
+  1.抽象类负责描述的是事物的基本功能，可以定义非抽象方法，
  接口只能定义抽象方法，接口负责描述事物的扩展功能
+  2.类与类之间是继承关系 is a 关系  
  类与接口之间是实现关系 like a 关系

> throw 和 throws 区别
+ throw 用在函数内，throws用在函数上
+ throw 抛出的是异常对象，throws抛出异常类声明，后面的异常类可以有多个，用逗号分开
+ 如果异常没有被catch 处理，就需要写throws


> 异常在继承或者实现中的使用细节：★★★★★
+ 1,子类覆盖父类方法时，如果父类的方法声明异常，子类只能声明父类异常或者该异常的子类，或者不声明。
+ 2,当父类方法声明多个异常时，子类覆盖时只能声明多个异常的子集。
+ 3,当被覆盖的方法没有异常声明时，子类覆盖时时无法声明异常的。
+ 举例：父类存在这种情况，接口也有这种情况，
	问题：接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？
		　无法进行throws声明，只能catch的捕获。万一问题处理不了呢？catch中继续throw抛出，但是只能将异常转换成RuntimeException子类抛出。

	Interface Inter
	{
		public void show();
	}
	class Demo implement Inter
	{
		public void show()
		{
			try{
				throw new Exception();
			}catch(Exception e)
			{
				code...;
				throw new RuntimeException("");// 告知调用者问题所在。
			}
		}
	}


            public	   protected      default       private
一个类中      ok			     ok			       ok			      	ok
一个包中      ok			     ok			       ok				
子类中        ok			     ok          
不同包中	    ok 


 sleep方法和wait方法异同点是什么？
	相同点：可以让线程处于冻结状态。
	不同点：
		1，
		sleep必须指定时间。
		wait可以指定时间，也可以不指定时间。
		2，
		sleep时间到，线程处于临时阻塞或者运行。
		wait如果没有时间，必须要通过notify或者notifyAll唤醒。
		3，
		sleep不一定非要定义在同步中。
		wait必须定义在同步中。
		4，
		都定义在同步中，
		线程执行到sleep，不会释放锁，会让出cpu执行权
		线程执行到wait，会释放锁，会让出cpu执行权
    5.
    sleep是线程中的方法，但是wait是Object中的方法。


    synchronized(obj)
{
	//sleep(5000);
	wait();//0 1 2 
	code....

}


synchronized(obj)
{
	notifyAll();//3
	code....
}


2，线程如何停止呢？★★★★
	stop方法过时了，看起描述发现，有其他解决方案。
	线程结束:就是让线程任务代码执行完，run方法结束。
	run方法咋结束呢？
	run方法中通常都定义循环，只要控制住循环就哦了。
	
	注意：万一线程在任务中处于了冻结状态，那么它还能去判断标记吗？不能！
	咋办？通过查阅stop方法的描述，发现提供了一个解决方法：
	如果目标线程等待很长时间，则应使用 interrupt 方法来中断该等待
	所谓的中断并不是停止线程。
	interrupt的功能是 将线程的冻结状态清除，让线程恢复到的运行状态(让线程重新具备cpu的执行资格)。
	因为时强制性的所以会有异常InterruptedException发生，可以在catch中捕获异常，
	在异常处理中，改变标记让循环结束，让run方法结束。


3，守护线程：也可以理解为后台线程，之前创建的都是前台线程。
	只要线程调用了setDaemon(true);就可以把线程标记为守护线程。
	前台后台线程运行时都是一样的，获取CPU的执行权执行。
	只有结束的时候有些不同。
	前台线程要通过run方法结束，线程结束。
	后台线程也可以通过run方法结束，线程结束，还有另一种情况，
	当进程中所有的前台线程都结束了，这时无论后台线程处于什么样的状态，都会结束，从而进程会结束。
	进程结束依赖的都是前台线程。


4，线程的优先级：用数字标识的，1-10   
	其中默认的初始优先级时5 最明显的三个优先级 1，5，10。
	setPriority(Thread.MAX_PRIORITY);

5，线程组：ThreadGroup：可以通过Thread的构造函数明确新线程对象所属的线程组。
	线程组的好处，可以对多个同组线程，进行统一的操作。
	默认都属于main线程组。


6，join方法，yield方法。

7，开发中，线程的匿名内部类体现。
//面试题：
	new Thread(new Runnable()
	{
		public void run()
		{
			System.out.println("runnable run");
		}
	}){
		public void run()
		{
			System.out.println("subthread run");//执行。
		}
	}.start();